DDD Model 
DDD Model içinde hem property'ler bulunur hem de Behavior(business rule)lar bulunuyor.
Örneðin sipariþteki tutar 3000'den fazlaysa þunu yap gibi kurallar ilgili entity içinde method olarak tanýmlanýr.

Anemic Domain Model
Anemic Domain Model'de ise sadece property'ler var. Klasik bildiðimiz yöntem. burada behaviorlar business layer'da oluyor.

1) PROJENÝN OLUÞTURULMASI
	Services altýnda 
		Presentation Layer için ASP.NET CORE API projesi ekledik. (Order.API)
		Application Layer için Class Library oluþturduk (Order.Application)
		Domain Layer için Class Library oluþturduk (Order.Domain)
		Yine Domain Layer için ama bu sefer (Aggregate vs için) class library oluþturduk (Order.Domain.Core)
		Infrs. Layer için Class library oluþturduk. (Order.Infrastructure)

		Order.API portu 5015 olcak þekilde ayarladýk.

2) Domain.Core'un geliþtirilmesi Entity, ValueObject ve IAggregateRoot. Bunlar base class'larýmýz. Domain'deki class'lar bunlardan miras alacak.
	Entity ve ValueObject class'larý oluþturuldu.
	IAggregateRoot interface'i oluþturuldu.
	Entity Class'ý içerisine equals tarzý karþýlaþtýrma methodlarýmýzý yazdýk.
	Ayný methodlarý ValueObject class'ýna da ekledik

3) Order (Entity, IAggregateRoot), OrderItem (Entity), Address (ValueObject) classlarýný yazýyoruz.
	Bu mimaride domain üzerinden gidiyoruz. Bu yüzden kimse kendi baþýna hareket edemiyor. Bu yüzden OrderItem eklemek istediðimiz zaman Order üzerinden ekleyeceðiz.

	OrderAggregate/Address.cs oluþturuldu. Dýþarýdan müdahale olmasýn diye proplarýn setleri private yapýldý. constructor ile deðer alcaz.
	Address ValueObject. Order içerisinde yer alcak fakat db'de bir tablo olarak yer almayacak ama kolonlarý Order tablosuna eklencek. 

	OrderAggregate/OrderItem.cs oluþturuldu. proplar private set yapýldý. ctor ile deðer alcaz. Bu deðerleri update için UpdateOrderItem methodu eklendi. 
	Miras olarak Entity alýyor. DDD'den dolayý.

	OrderAggregate/Order.cs oluþturuldu. Entity classýndan ve IAggregateRoot interface'inden miras alýyor.
	orderItems field olarak private readonly ekledik. Property'sini IReadOnlyCollection yaptýk. Burada DDD'den dolayý direkt Order üzerinden ekleme yapmasýný istemiyoruz.
	Ekleme yapýlacaksa benim yazdýðým method üzerinden ekleme yapýlmalý. 
	Çünkü ekleme yapýlan method benim kontrolümde olacak ve eklemenin benim kontrolüm altýndaki methoddan yapýlmasý gerek.
	proplarý private set yapýp ardýndan ctor yazdýk.
	orderitem eklemek için method yazdýk.

	Önemli Not: Domain katmaný hangi ORM aracýný kullandýðýmýzý bilmemeli, herhangi bir kütüphaneye baðýmlý olmamalýdýr. Saf c# kodu bulunmalý sadece.

4) OrderDBContext'i oluþturacaðýz. 
	Infrastructre Layer'da EF Core ve EfCore.Tools (migrationiçin )yüklüyoruz.
	SQL Server kullanacaðýmýz için EFCore.SqlServer da yükülyoruz.
	Bu layerda OrderDbContext class'ýmý oluþturduk ve DbContext sýnýfýndan miras aldýrdýk.
	ctor yazdýk ve options parametresi alýp base ctor a yolladýk.
	Order ve OrderItem Entity'lerim için DbSet propertylerini tanýmladýk. Address için tanýmlamadýk, çünkü value object. Db karþýlýðý olmayacak.
	OnModelCreating methodumuzu override ettik. Bunun için ToTable diyerek tablo db karþýlýklarý ayarýný yaptýk. Price için decimal tipinin detayýný verdik 18,2
		Ayrýca Address ValueObject olduðu için Order için OwnsOne Address diyerek OwnerType olduðunu bildirdik.

5) Dto'larýmýzý oluþturuyoruz => AddressDto, OrderDto, OrderItemDto, CreatedOrderDto
	Application katmanýnda oluþturuyoruz.

6) AutoMapper ekliyoruz. ClassLibrary'de kullanacaðýmýz için Dependency Injection versiyonlu olmayan AutoMapper'ý ekledik.
	Veritabanýndan aldýðýmýz verileri dto'ya çevirmede kullanacaðýz. CustomMapper'da maplenecek class'larý verdik. Class'ý mapping klasörü altýnda oluþturduk
	Sadece istenildiði zaman maplemeyi yapacak olan (LAZY) ObjectMapper static class'ýný da oluþturuyoruz. 